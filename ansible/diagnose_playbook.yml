---
- name: 1. VPS Diagnostica â€“ Acquisizione Log e Stato Disco Condizionale
Â  hosts: allÂ 
Â  become: true

Â  # Rimosse le righe relative ad ansible_connection: "{{ ... else omit }}"

Â  vars:
Â  Â  # Variabili di Setup Essenziali
Â  Â  mount_point: "/mnt/vps"
Â  Â  target_partition: "/dev/vda1" # Placeholder, da sovrascrivere con -e


Â  Â  # 1. Definisce il nome della directory temporanea (basato sulla data/ora)
Â  Â  log_dir_name: "logs_{{ ansible_date_time.iso8601_basic | replace('T', '-') | replace(':', '-') | replace('Z', '') }}"
Â  Â Â 
Â  Â  # 2. Definisce il percorso remoto completo (/tmp/logs_DATA...)
Â  Â  log_dest: "/tmp/{{ log_dir_name }}"
Â  Â Â 
Â  Â  # 3. Definisce il nome dell'archivio remoto
Â  Â  tar_file_remote: "/tmp/{{ log_dir_name }}.tar.gz"
Â  Â Â 
Â  Â  # 4. Definisce il percorso di download locale (Control Node)
Â  Â  # Usa il percorso assoluto per evitare ambiguitÃ  (risolve il problema precedente)
Â  Â  local_download_dir: "{{ lookup('env', 'PWD') }}/vps_diagnostics_output"
Â  Â 
Â  # ðŸ›‘ BLOCCO INIZIALE PER LA MODALITÃ€ LOCALE ðŸ›‘
Â  pre_tasks:
Â  Â  - name: Set connection to local if EXECUTION_MODE is LOCAL
Â  Â  Â  ansible.builtin.set_fact:
Â  Â  Â  Â  ansible_connection: local
Â  Â  Â  when: (EXECUTION_MODE | default('REMOTE')) == 'LOCAL'

Â  tasks:
Â  Â  # 1. SETUP REMOTO E MOUNT (Sola Lettura)
Â  Â  - name: Create temporary mount point directory on Live ISO
Â  Â  Â  ansible.builtin.file:
Â  Â  Â  Â  path: "{{ mount_point }}"
Â  Â  Â  Â  state: directory
Â  Â  Â  Â  mode: '0755'

Â  Â  - name: Mount target partition READONLY (Safety Check)
Â  Â  Â  ansible.posix.mount:
Â  Â  Â  Â  path: "{{ mount_point }}"
Â  Â  Â  Â  src: "{{ target_partition }}"
Â  Â  Â  Â  fstype: auto
Â  Â  Â  Â  opts: ro
Â  Â  Â  Â  state: mounted

Â  Â  - name: Create log destination directory on Live ISO's /tmp
Â  Â  Â  ansible.builtin.file:
Â  Â  Â  Â  path: "{{ log_dest }}"
Â  Â  Â  Â  state: directory
Â  Â  Â  Â  mode: '0755'

Â  Â  # 2. RUN DIAGNOSTICS (Journal, Disk Check, Bind Mounts)
Â  Â  - name: Run complex diagnostic steps (Journal, Disk Check, Bind Mounts)
Â  Â  Â  ansible.builtin.shell: |
Â  Â  Â  Â  set +e
Â  Â  Â  Â  mkdir -p "{{ mount_point }}/proc" "{{ mount_point }}/sys"
Â  Â  Â  Â  mount -o bind /proc "{{ mount_point }}/proc"
Â  Â  Â  Â  mount -o bind /sys "{{ mount_point }}/sys"

Â  Â  Â  Â  echo "--- LOG JOURNAL (LAST 500) ---" > "{{ log_dest }}/target_journal_last500.txt"
Â  Â  Â  Â  chroot "{{ mount_point }}" journalctl -r -n 500 --no-pager >> "{{ log_dest }}/target_journal_last500.txt" 2>&1
Â  Â  Â  Â Â 
Â  Â  Â  Â  echo -e "\n--- RAPPORTO UTILIZZO DISCO (df -h) ---" > "{{ log_dest }}/target_disk_usage.txt"
Â  Â  Â  Â  chroot "{{ mount_point }}" df -h >> "{{ log_dest }}/target_disk_usage.txt" 2>&1

Â  Â  Â  Â  cp "{{ mount_point }}/var/log/syslog" "{{ log_dest }}/target_syslog_copy" || trueÂ 

Â  Â  Â  Â  umount "{{ mount_point }}/sys"
Â  Â  Â  Â  umount "{{ mount_point }}/proc"
Â  Â  Â  args:
Â  Â  Â  Â  executable: /bin/bash
Â  Â  Â  ignore_errors: yes

Â  Â  # 3. CLEANUP AND DOWNLOAD (AUTOMAZIONE)
Â  Â  - name: Unmount target partition
Â  Â  Â  ansible.posix.mount:
Â  Â  Â  Â  path: "{{ mount_point }}"
Â  Â  Â  Â  state: absent

Â  Â  - name: Archive log directory before download
Â  Â  Â  ansible.builtin.shell: tar czf "{{ tar_file_remote }}" -C /tmp "{{ log_dir_name }}"

Â  Â  - name: Download log archive to Control Node
Â  Â  Â  ansible.builtin.fetch:
Â  Â  Â  Â  src: "{{ tar_file_remote }}"
Â  Â  Â  Â  # Usa un percorso assoluto per la destinazione locale
Â  Â  Â  Â  dest: "{{ local_download_dir }}/"Â 
Â  Â  Â  Â  # NON usare 'flat: yes'. Permette a fetch di creare la directory host IP/
Â  Â  Â  Â  flat: noÂ 
Â  Â  Â  register: fetch_result
Â  Â  Â  when: (EXECUTION_MODE | default('REMOTE')) == 'REMOTE'

Â  Â  # Task Locale 1: Crea la directory locale di destinazione
Â  Â  - name: Ensure local log directory exists
Â  Â  Â  ansible.builtin.file:
Â  Â  Â  Â  path: "{{ local_download_dir }}/{{ log_dir_name }}"
Â  Â  Â  Â  state: directory
Â  Â  Â  Â  mode: '0700'
Â  Â  Â  delegate_to: localhost
Â  Â  Â  become: false

Â  Â  # Task Locale 2: Copia (LOCAL) o Estrazione (REMOTE)
Â  Â  - name: Handle final log copy/extraction on Control Node
Â  Â  Â  ansible.builtin.shell: | # <-- USARE IL SIMBOLO PIPE QUI
Â  Â  Â  Â  # Definisci tutte le variabili shell all'inizio per evitare ambiguitÃ 
Â  Â  Â  Â  EXEC_MODE="{{ EXECUTION_MODE | default('REMOTE') }}"
Â  Â  Â  Â  FINAL_OUTPUT_DIR="{{ local_download_dir }}/{{ inventory_hostname }}/{{ log_dir_name }}"
Â  Â  Â  Â  LOG_DEST="{{ log_dest }}"
Â  Â  Â  Â  FETCH_SRC_FILE="{{ local_download_dir }}/{{ inventory_hostname }}/tmp/{{ log_dir_name }}.tar.gz"

Â  Â  Â  Â  mkdir -p "$FINAL_OUTPUT_DIR"
Â  Â  Â  Â Â 
Â  Â  Â  Â  if [[ "$EXEC_MODE" == "LOCAL" ]]; then
Â  Â  Â  Â  Â  # 1. ModalitÃ  Locale: Copia diretta da /tmp
Â  Â  Â  Â  Â  cp -r "$LOG_DEST"/* "$FINAL_OUTPUT_DIR/"
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  else
Â  Â  Â  Â  Â  # 2. ModalitÃ  Remota: Estrazione dell'archivio scaricato da fetch
Â  Â  Â  Â  Â  # Verifica che il file scaricato esista prima di estrarre
Â  Â  Â  Â  Â  if [ -f "$FETCH_SRC_FILE" ]; then
Â  Â  Â  Â  Â  Â  tar xzf "$FETCH_SRC_FILE" -C "$FINAL_OUTPUT_DIR/" --strip-components=1
Â  Â  Â  Â  Â  else
Â  Â  Â  Â  Â  Â  echo "ERRORE: Archivio scaricato non trovato in $FETCH_SRC_FILE" >&2
Â  Â  Â  Â  Â  Â  exit 1
Â  Â  Â  Â  Â  fi
Â  Â  Â  Â  fi
Â  Â  Â  delegate_to: localhost
Â  Â  Â  become: false
Â  Â  Â  # Questo task non ha bisogno della condizione when, gestisce la logica internamente

Â  Â  - name: Print success message with final output path
Â  Â  Â  ansible.builtin.debug:
Â  Â  Â  Â  msg: "âœ… DIAGNOSTICA COMPLETATA. Log salvati in: {{ local_download_dir }}/{{ inventory_hostname }}/{{ log_dir_name }}/"
