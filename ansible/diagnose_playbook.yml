---
- name: 1. VPS Diagnostica â€“ Acquisizione Log e Stato Disco Condizionale
  hosts: all 
  become: true

  # Rimosse le righe relative ad ansible_connection: "{{ ... else omit }}"

  vars:
    # ðŸ›‘ Variabili di Setup Essenziali (Aggiunte per risolvere l'errore 'undefined')
    mount_point: "/mnt/vps"
    
    # ATTENZIONE: target_partition DEVE essere sovrascritta nel comando di esecuzione
    target_partition: "/dev/vda1" # Placeholder, da sovrascrivere con -e

    # Percorso locale (Control Node) - Usa percorso assoluto per evitare ambiguitÃ 
    local_download_dir: "{{ lookup('env', 'PWD') }}/vps_diagnostics_output"
    ## Genera un nome di directory univoco per i log e la sottodirectory locale
    #log_dir_name: "logs_{{ ansible_date_time.iso8601_basic | replace('T', '-') | replace(':', '-') | replace('Z', '') }}"
    # Percorsi remoti
    log_dest: "/tmp/{{ log_dir_name }}"
    tar_file_remote: "/tmp/{{ log_dir_name }}.tar.gz"
    # Percorso locale (Control Node)
    local_download_dir: "./vps_diagnostics_output"

  # ðŸ›‘ BLOCCO INIZIALE PER LA MODALITÃ€ LOCALE ðŸ›‘
  pre_tasks:
    - name: Set connection to local if EXECUTION_MODE is LOCAL
      ansible.builtin.set_fact:
        ansible_connection: local
      when: (EXECUTION_MODE | default('REMOTE')) == 'LOCAL'

  tasks:
    # 1. SETUP REMOTO E MOUNT (Sola Lettura)
    - name: Create temporary mount point directory on Live ISO
      ansible.builtin.file:
        path: "{{ mount_point }}"
        state: directory
        mode: '0755'

    - name: Mount target partition READONLY (Safety Check)
      ansible.posix.mount:
        path: "{{ mount_point }}"
        src: "{{ target_partition }}"
        fstype: auto
        opts: ro
        state: mounted

    - name: Create log destination directory on Live ISO's /tmp
      ansible.builtin.file:
        path: "{{ log_dest }}"
        state: directory
        mode: '0755'

    # 2. RUN DIAGNOSTICS (Journal, Disk Check, Bind Mounts)
    - name: Run complex diagnostic steps (Journal, Disk Check, Bind Mounts)
      ansible.builtin.shell: |
        set +e
        mkdir -p "{{ mount_point }}/proc" "{{ mount_point }}/sys"
        mount -o bind /proc "{{ mount_point }}/proc"
        mount -o bind /sys "{{ mount_point }}/sys"

        echo "--- LOG JOURNAL (LAST 500) ---" > "{{ log_dest }}/target_journal_last500.txt"
        chroot "{{ mount_point }}" journalctl -r -n 500 --no-pager >> "{{ log_dest }}/target_journal_last500.txt" 2>&1
        
        echo -e "\n--- RAPPORTO UTILIZZO DISCO (df -h) ---" > "{{ log_dest }}/target_disk_usage.txt"
        chroot "{{ mount_point }}" df -h >> "{{ log_dest }}/target_disk_usage.txt" 2>&1

        cp "{{ mount_point }}/var/log/syslog" "{{ log_dest }}/target_syslog_copy" || true 

        umount "{{ mount_point }}/sys"
        umount "{{ mount_point }}/proc"
      args:
        executable: /bin/bash
      ignore_errors: yes

    # 3. CLEANUP AND DOWNLOAD (AUTOMAZIONE)
    - name: Unmount target partition
      ansible.posix.mount:
        path: "{{ mount_point }}"
        state: absent

    - name: Archive log directory before download
      ansible.builtin.shell: tar czf "{{ tar_file_remote }}" -C /tmp "{{ log_dir_name }}"

    - name: Download log archive to Control Node
      ansible.builtin.fetch:
        src: "{{ tar_file_remote }}"
        # Usa un percorso assoluto per la destinazione locale
        dest: "{{ local_download_dir }}/" 
        # NON usare 'flat: yes'. Permette a fetch di creare la directory host IP/
        flat: no 
      register: fetch_result
      when: (EXECUTION_MODE | default('REMOTE')) == 'REMOTE'

    # Task Locale 1: Crea la directory locale di destinazione
    - name: Ensure local log directory exists
      ansible.builtin.file:
        path: "{{ local_download_dir }}/{{ log_dir_name }}"
        state: directory
        mode: '0700'
      delegate_to: localhost
      become: false

    # Task Locale 2: Copia (LOCAL) o Estrazione (REMOTE)
    - name: Handle final log copy/extraction on Control Node
      ansible.builtin.shell: | # <-- USARE IL SIMBOLO PIPE QUI
        # Definisci tutte le variabili shell all'inizio per evitare ambiguitÃ 
        EXEC_MODE="{{ EXECUTION_MODE | default('REMOTE') }}"
        FINAL_OUTPUT_DIR="{{ local_download_dir }}/{{ inventory_hostname }}/{{ log_dir_name }}"
        LOG_DEST="{{ log_dest }}"
        FETCH_SRC_FILE="{{ local_download_dir }}/{{ inventory_hostname }}/tmp/{{ log_dir_name }}.tar.gz"

        mkdir -p "$FINAL_OUTPUT_DIR"
        
        if [[ "$EXEC_MODE" == "LOCAL" ]]; then
          # 1. ModalitÃ  Locale: Copia diretta da /tmp
          cp -r "$LOG_DEST"/* "$FINAL_OUTPUT_DIR/"
          
        else
          # 2. ModalitÃ  Remota: Estrazione dell'archivio scaricato da fetch
          # Verifica che il file scaricato esista prima di estrarre
          if [ -f "$FETCH_SRC_FILE" ]; then
            tar xzf "$FETCH_SRC_FILE" -C "$FINAL_OUTPUT_DIR/" --strip-components=1
          else
            echo "ERRORE: Archivio scaricato non trovato in $FETCH_SRC_FILE" >&2
            exit 1
          fi
        fi
      delegate_to: localhost
      become: false
      # Questo task non ha bisogno della condizione when, gestisce la logica internamente

    - name: Print success message with final output path
      ansible.builtin.debug:
        msg: "âœ… DIAGNOSTICA COMPLETATA. Log salvati in: {{ local_download_dir }}/{{ inventory_hostname }}/{{ log_dir_name }}/"
